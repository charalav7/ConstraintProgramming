/***
 * Assignment 4, Task 5
 * Authors:	Vasileios Charalampidis,
 * 			Karl GÃ¤fvert
 * 			(Group 20)
 * 
 * 
 * 
 * Maximum density still life patterns that were found of sizes 8 and 9 together with their densities:
 * 
    Life
    1 0 0 1 0 0 1 0
    1 1 1 1 1 1 1 0
    0 0 0 0 0 0 0 0
    1 1 0 0 1 1 0 1
    1 1 0 0 1 0 1 1
    0 0 0 0 0 0 0 0
    1 1 0 0 1 0 1 1
    1 1 0 0 1 1 0 1
    Size: 8
    Density: 30

    0 1 0 0 1 0 0 1
    0 1 1 1 1 1 1 1
    0 0 0 0 0 0 0 0
    1 0 1 1 1 0 1 1
    1 1 0 0 1 0 1 0
    0 0 0 1 0 0 1 0
    1 1 0 1 0 1 0 0
    1 0 1 1 0 1 1 0
    Size: 8
    Density: 31

    1 0 0 1 0 0 0 0
    1 1 1 1 1 1 0 0
    0 0 0 0 0 0 1 0
    1 1 0 1 1 0 1 0
    1 1 0 1 1 0 1 1
    0 0 0 0 0 0 1 0
    1 1 0 1 1 0 1 0
    1 1 0 1 1 0 1 1
    Size: 8
    Density: 32

    1 0 0 1 0 0 0 0
    1 1 1 1 1 1 0 1
    0 0 0 0 0 0 1 1
    1 1 0 1 1 0 0 0
    1 1 0 1 1 0 1 1
    0 0 0 0 0 0 1 0
    1 1 0 1 1 0 1 0
    1 1 0 1 1 0 1 1
    Size: 8
    Density: 33

    1 0 0 1 0 1 1 0
    1 1 1 1 1 0 0 1
    0 0 0 0 0 0 1 1
    1 1 0 1 1 0 1 0
    1 1 0 1 1 0 1 0
    0 0 0 0 0 0 1 1
    1 1 1 1 1 0 0 1
    1 0 0 1 0 1 1 0
    Size: 8
    Density: 34

    1 1 0 1 1 0 1 1
    0 1 0 1 1 0 1 1
    1 0 0 0 0 0 0 0
    1 1 1 1 1 0 1 1
    0 0 0 0 1 0 1 1
    1 1 0 0 1 0 0 0
    1 0 1 0 1 0 1 1
    0 1 1 0 1 1 0 1
    Size: 8
    Density: 35

    1 1 0 1 1 0 1 1
    1 1 0 1 1 0 1 1
    0 0 0 0 0 0 0 0
    1 1 0 1 1 0 1 1
    1 1 0 1 1 0 1 1
    0 0 0 0 0 0 0 0
    1 1 0 1 1 0 1 1
    1 1 0 1 1 0 1 1
    Size: 8
    Density: 36


    Initial
            propagators: 400
            branchers:   1

    Summary
            runtime:      3:01.867 (181867.000 ms)
            solutions:    7
            propagations: 434471044
            nodes:        12632279
            failures:     6316133
            restarts:     0
            no-goods:     0
            peak depth:   37


    Life
    0 0 1 1 0 1 0 0 0
    0 1 0 0 1 1 1 1 0
    0 1 1 0 0 0 0 0 1
    0 0 1 0 1 1 0 1 0
    0 1 0 0 1 1 0 1 1
    0 1 1 0 0 0 0 0 1
    0 0 1 0 1 1 0 1 0
    0 1 0 0 1 1 0 1 1
    0 1 1 0 0 0 0 0 0
    Size: 9
    Density: 34

    0 0 1 1 0 1 1 0 0
    0 1 0 0 1 1 0 0 1
    0 1 1 0 0 0 0 1 1
    0 0 1 0 1 1 0 1 0
    0 1 0 0 1 1 0 0 1
    0 1 1 0 0 0 0 1 1
    0 0 1 0 1 1 0 1 0
    0 1 0 0 1 1 0 0 1
    0 1 1 0 0 0 0 1 1
    Size: 9
    Density: 36

    0 0 1 1 0 1 0 0 1
    0 1 0 0 1 1 1 1 1
    0 1 1 0 0 0 0 0 0
    0 0 1 0 1 1 1 1 1
    0 1 0 0 1 0 0 0 1
    0 1 1 0 1 0 1 0 0
    0 0 1 0 1 0 1 1 0
    0 1 0 0 1 1 0 0 1
    0 1 1 0 0 0 0 1 1
    Size: 9
    Density: 37

    0 0 1 1 0 1 0 0 1
    0 1 0 0 1 1 1 1 1
    0 1 1 0 0 0 0 0 0
    0 0 1 0 1 1 1 1 1
    0 1 0 0 1 0 0 0 1
    0 1 1 0 1 0 1 0 0
    0 0 1 0 1 0 1 1 0
    0 0 1 0 1 0 0 0 1
    0 1 1 0 1 1 0 1 1
    Size: 9
    Density: 38

    0 0 1 1 0 1 0 1 1
    0 1 0 0 1 1 0 1 0
    0 1 1 0 0 0 0 0 1
    0 0 1 0 1 1 1 1 1
    0 1 0 0 1 0 0 0 0
    0 1 1 0 0 1 1 1 1
    0 0 0 1 1 0 0 0 1
    1 0 1 0 0 1 0 1 0
    1 1 0 0 1 1 0 1 1
    Size: 9
    Density: 39

    0 0 1 1 0 1 0 1 1
    0 1 0 0 1 1 0 1 0
    0 1 1 0 0 0 0 0 1
    0 0 1 0 1 1 1 1 1
    1 0 0 1 0 0 0 0 0
    1 1 1 0 0 1 1 1 1
    0 0 0 1 1 0 0 0 1
    1 1 1 0 0 1 0 1 0
    1 0 0 0 1 1 0 1 1
    Size: 9
    Density: 40

    0 0 1 1 0 0 0 1 1
    0 1 0 0 1 0 1 0 1
    0 1 1 0 1 0 1 0 0
    0 0 1 0 1 0 1 1 0
    1 0 0 0 1 0 0 0 1
    1 1 1 1 0 1 1 1 1
    0 0 0 1 0 1 0 0 0
    1 1 0 1 0 1 0 1 1
    1 0 1 1 0 1 1 0 1
    Size: 9
    Density: 41

    0 1 1 0 1 1 0 1 1
    0 1 0 0 0 1 0 1 0
    0 0 1 0 1 0 0 0 1
    0 1 1 0 1 1 1 1 1
    1 0 0 1 0 0 0 0 0
    1 1 0 1 0 1 1 1 1
    0 1 0 1 0 1 0 0 1
    1 0 0 1 0 1 0 1 0
    1 1 0 0 1 1 0 1 1
    Size: 9
    Density: 42

    0 1 1 0 1 1 0 1 1
    0 0 1 0 1 1 0 1 0
    1 0 1 0 0 0 0 0 1
    1 1 0 1 1 1 1 1 1
    0 0 0 1 0 0 0 0 0
    1 1 0 1 0 1 1 1 1
    0 1 0 1 0 1 0 0 1
    1 0 0 1 0 1 0 1 0
    1 1 0 0 1 1 0 1 1
    Size: 9
    Density: 43


    Initial
            propagators: 506
            branchers:   9

    Summary
            runtime:      26:27.466 (1587466.000 ms)
            solutions:    9
            propagations: 3607314690
            nodes:        151012867
            failures:     75506425
            restarts:     0
            no-goods:     0
            peak depth:   49

 ***/

#include <gecode/driver.hh>
#include <gecode/int.hh>
#include <gecode/minimodel.hh>

using namespace Gecode;

class Life : public Script {
  private:
    BoolVarArray cells; // cells array indicating 1 for alive cell and 0 for dead one
    static int n; // the size of the pattern
    
  public:
    Life(const SizeOptions &opt): Script(opt),
        cells(*this, n * n, 0, 1)
    {
        Matrix <BoolVarArray> pattern(cells, n);

        /**
         * To ensure that the pattern does not spread we add a border of size 2.
         * We set it to empty by defining its sum of corresponding rows and columns to 0.  
         */
        for (int i = 0; i < 2; i++) {
            linear(*this, pattern.row(i), IRT_EQ, 0, opt.ipl());
            linear(*this, pattern.col(i), IRT_EQ, 0, opt.ipl());
            linear(*this, pattern.row((n - 1) - i), IRT_EQ, 0, opt.ipl());
            linear(*this, pattern.col((n - 1) - i), IRT_EQ, 0, opt.ipl());
        }
            
        /**
         * Check the sum of alive cells for the 8 neighbors around the cell of interest.
         * If sum == 2 or sum == 3 then the cell is alive. Otherwise it is dead. 
         */
        for (int i = 1; i < n - 1; i++) {
            for (int j = 1; j < n - 1; j++) {
                BoolVarArray neighbors = BoolVarArray(*this, 8);
                neighbors[0] = pattern(i - 1, j - 1);
                neighbors[1] = pattern(i - 1, j);
                neighbors[2] = pattern(i - 1, j + 1);
                neighbors[3] = pattern(i, j - 1);
                neighbors[4] = pattern(i, j + 1);
                neighbors[5] = pattern(i + 1, j - 1);
                neighbors[6] = pattern(i + 1, j);
                neighbors[7] = pattern(i + 1, j + 1);
                 
                rel(*this, pattern(i, j) >> (sum(neighbors) == 2 || sum(neighbors) == 3));
                rel(*this, !pattern(i, j) >> (sum(neighbors) != 3));
            }
        }

        /**
         * Check whether the given pattern size can be divided by squares of size 3. If not proceed with simple branching.
         * If it can be divided, then slice appropriately the pattern matrix, and branch accordingly.
         */
        if ((n - 4) % 3 != 0) {
            // Simple branching. Using an AFC-based branching is a good idea
            branch(*this, cells, BOOL_VAR_AFC_MAX(), BOOL_VAL_MAX());   
        }
        else {
            for (int i = 2; i < n - 2; i += 3) {
                for (int j = 2; j < n - 2; j += 3) {
                    rel(*this, sum(pattern.slice(i, i + 3, j, j + 3)) <= 6); // We know that the max sum of a 3 by 3 square is 6
                    branch(*this, pattern.slice(i, i + 3, j, j + 3), BOOL_VAR_AFC_MAX(), BOOL_VAL_MAX());
                }
            }
        }  
    }

    // Constructor for cloning
    Life(Life& sq) : Script(sq) {
      cells.update(*this, sq.cells);
    }

    // Perform copying during cloning
    virtual Space* copy(void) {
      return new Life(*this);
    }

    // Print solution
    virtual void print(std::ostream& os) const {
        int density = 0;
        for (int row = 2; row < n - 2; row++) {
			for (int col = 2; col < n - 2; col++) {
                if (cells[row*n + col].val()) density++;
                os << cells[row*n + col] << ' ';
            }
            os << std::endl;	
		}
        os << "Size: " << n - 4 << std::endl;
        os << "Density: " << density << std::endl;
        os << std::endl;
    }

    /**
     * Implement an additional method to get the maximum density for our pattern.
     * Basically, we want to print until the best solution found, and that is 
     * the sum of the new alive cells to be greater than the old one.
     * We make sure that the int method uses a branch-and-bound (BAB) search engine,
     * rather than a plain depth-first engine.
     */
    virtual void constrain(const Space& sp) {
        const Life& lf = static_cast<const Life&>(sp);
        rel(*this, sum(cells) > sum(lf.cells));
    }

    // Set the size of the pattern. Include a border of size 2 around it.
    static void set_n(const int argn) {
        n = argn + 4;
    }

};

// Make compiler happy
int Life::n = 7;

int main(int argc, char* argv[]) {
    SizeOptions opt("Life");
    opt.ipl(IPL_DOM);
    opt.size(3);
    opt.parse(argc, argv);
    if (opt.size() < 3) {
        std::cerr << "The minimum number of board size is 3";
        return -1;
    }
    Life::set_n(opt.size());
    opt.solutions(0); // Important to set to 0, to display all solutions
    Script::run<Life, BAB, SizeOptions>(opt); // Important to set BAB search engine
    return 0;
}